"use strict";(self.webpackChunkpage=self.webpackChunkpage||[]).push([[733],{7038:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var s=i(4848),t=i(8453);const a={sidebar_position:1,slug:"solid-principles"},c="SOLID",r={id:"clean-code/SolidPrinciples",title:"SOLID",description:"Object-Oriented Design is about modelling concepts with classes/objects, and",source:"@site/docs/clean-code/SolidPrinciples.md",sourceDirName:"clean-code",slug:"/clean-code/solid-principles",permalink:"/software-basics/clean-code/solid-principles",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,slug:"solid-principles"},sidebar:"tutorialSidebar",previous:{title:"Clean Code",permalink:"/software-basics/category/clean-code"},next:{title:"More Principles",permalink:"/software-basics/clean-code/more-useful-principles"}},o={},l=[{value:"Single Responsibility Principle",id:"single-responsibility-principle",level:3},{value:"Open/Closed Principle",id:"openclosed-principle",level:3},{value:"Liskov Substitution Principle",id:"liskov-substitution-principle",level:3},{value:"Interface Segregation Principle",id:"interface-segregation-principle",level:3},{value:"Dependency Inversion Principle",id:"dependency-inversion-principle",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",header:"header",hr:"hr",img:"img",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"solid",children:"SOLID"})}),"\n",(0,s.jsx)(n.p,{children:"Object-Oriented Design is about modelling concepts with classes/objects, and\nmanaging their dependencies. It is a set of coding techniques that arrange\ndependencies such that objects can tolerate future changes."}),"\n",(0,s.jsx)(n.h3,{id:"single-responsibility-principle",children:"Single Responsibility Principle"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://res.cloudinary.com/dldviopcu/image/upload/v1733416095/Pasted_image_20241205230942.png",alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["Don't put functions/ methods, that change for different reasons, in the same\nclass; ie. a class should have only one reason to change\nIf for eg. we change ",(0,s.jsx)(n.code,{children:"reportHours"})," func (for instance to change the format from\ndecimal to fractional hours - 'and a half'), the change shouldn't\nimpact ",(0,s.jsx)(n.code,{children:"calcPay"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"openclosed-principle",children:"Open/Closed Principle"}),"\n",(0,s.jsx)(n.p,{children:"Modules should be open for extension, but closed for modification."}),"\n",(0,s.jsx)(n.p,{children:"Write classes in such a way that when you need to extend it to support more\nfunctionality, you don 't have to change its existing code / implementation."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Bad"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"class Shape {\n}\n\nclass Circle extends Shape {\n}\n\nclass Square extends Shape {\n}\n\nclass DrawAllShapes {\n    drawAllShapes(Shape[] shapes) {\n        for (type in shapes) {\n            switch (type) {\n                case square:\n                    square.drawSquare()\n                case circle:\n                    circle.drawCircle()\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Issue: When adding new shape ",(0,s.jsx)(n.code,{children:"Oval"}),", ",(0,s.jsx)(n.code,{children:"Square"})," and ",(0,s.jsx)(n.code,{children:"Circle"})," classes will also\nneed to be recompiled, and the switch statement will need to be modified."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Good"})," (if we only care about adding new shapes)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"class Shape {\n    draw()\n}\n\nclass Circle extends Shape {\n    draw()\n}\n\nclass Square extends Shape {\n    draw()\n}\n\nclass DrawAllShapes {\n    drawAllShapes(Shape[] shapes) {\n        for (shape in shapes) {\n            shape.draw()\n        }\n    }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now, adding ",(0,s.jsx)(n.code,{children:"Oval"})," class will not need any modification in\nclass ",(0,s.jsx)(n.code,{children:"DrawAllShapes"}),". It can just be included in the input shape list arg."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"}),"\nIf we want to draw all squares first (ordering), we could have built an\nabstraction in the current ",(0,s.jsx)(n.code,{children:"DrawAllShapes"}),' class to handle it. This indicates\nthat we need to have some idea of the "axis of movement" when writing a\nclass and using OOP to protect us from changing requirements.']}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"liskov-substitution-principle",children:"Liskov Substitution Principle"}),"\n",(0,s.jsxs)(n.p,{children:["Objects of a superclass should be replaceable by objects of a subclass without\naffecting the ",(0,s.jsx)("u",{children:"correctness"})," of the program."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://res.cloudinary.com/dldviopcu/image/upload/v1733416095/Pasted_image_20241205233122.png",alt:""})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"interface-segregation-principle",children:"Interface Segregation Principle"}),"\n",(0,s.jsx)(n.p,{children:"Uncle Bob: \u201cClients should not be forced to depend upon interfaces that they do\nnot [entirely] use\u201c."}),"\n",(0,s.jsx)(n.p,{children:"It aims to reduce the side effects of using larger interfaces by breaking the\napplication interfaces into smaller ones. Each class or interface should serve a\nsingle purpose."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://www.baeldung.com/java-interface-segregation",children:"Baeldung"}),": Precise\napplication design and correct abstraction is the key behind the Interface\nSegregation Principle.",(0,s.jsx)(n.strong,{children:"Though it\u2019ll take more time and effort in the design\nphase of an application and might increase the code complexity, in the end, we\nget a flexible code."})]}),"\n",(0,s.jsx)(n.p,{children:"As more features come in, we need to add a LoanPayment service:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public interface Payment {\n    // original methods\n    void initiatePayments();\n\n    Object status();\n\n    List<Object> getPayments();\n\n    // new methods added as more features come in\n    void intiateLoanSettlement();\n\n    void initiateRePayment();\n}\n\npublic class LoanPayment implements Payment {\n    @Override\n    public void initiatePayments() {\n        throw new UnsupportedOperationException("This is not a bank payment");\n    }\n\n    @Override\n    public Object status() {\n        // ...\n    }\n    // other methods...\n}\n\npublic class BankPayment implements Payment {\n    @Override\n    public void initiatePayments() {\n        // ...\n    }\n\n    @Override\n    public Object status() {\n        // ...\n    }\n\n    // other methods...\n    @Override\n    public void intiateLoanSettlement() {\n        throw new UnsupportedOperationException("This is not a loan payment");\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note that the_BankPayment_implementation now has implemented the new methods.\nAnd since it does not need them and has no logic for them, it\u2019s",(0,s.jsx)(n.strong,{children:"just throwing\nan UnsupportedOperationException. This is where we start violating the\nprinciple."})]}),"\n",(0,s.jsx)(n.p,{children:"Improved:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public interface Payment {\n    Object status();\n\n    List<Object> getPayments();\n}\n\npublic interface Bank extends Payment {\n    void initiatePayments();\n}\n\npublic interface Loan extends Payment {\n    void intiateLoanSettlement();\n\n    void initiateRePayment();\n}\n\npublic class BankPayment implements Bank {\n    @Override\n    public void initiatePayments() {\n        // ...\n    }\n\n    @Override\n    public Object status() {\n        // ...\n    }\n\n    @Override\n    public List<Object> getPayments() {\n        // ...\n    }\n}\n\npublic class LoanPayment implements Loan {\n    @Override\n    public void intiateLoanSettlement() {\n        // ...\n    }\n\n    @Override\n    public void initiateRePayment() {\n        // ...\n    }\n\n    @Override\n    public Object status() {\n        // ...\n    }\n\n    @Override\n    public List<Object> getPayments() {\n        // ...\n    }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"dependency-inversion-principle",children:"Dependency Inversion Principle"}),"\n",(0,s.jsx)(n.p,{children:"Dependency Inversion is the strategy of depending upon interfaces or abstract\nfunctions and classes rather than upon concrete functions and classes.\nComponents should work in isolation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"interface InterfaceB {\n    method()\n}\n\nclass ClassB implements InterfaceB {\n// fields, constructor and methods\n}\n\nclass ObjectA {\n    InterfaceB objectB;\n\n    ObjectA(InterfaceB objectB) {\n        this.objectB = objectB;\n    }\n    //...\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.baeldung.com/cs/dip#why-is-the-dependency-inversion-principle-important",children:"From Baeldung"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Why Is the Dependency Inversion Principle Important?"})}),"\n",(0,s.jsx)(n.p,{children:"When we write code for applications, we might split our logic into multiple\nmodules. Nonetheless, this will result in a code with dependencies. One\nmotivation behind DIP is to prevent us from depending upon modules that often\nchange. Concrete classes change frequently, while abstractions and interfaces\nchange much less. For example, operations like bug fixing, code recompiling, or\nmerging different branches will be much easier."}),"\n",(0,s.jsx)(n.p,{children:"However, there is more to it. DIP is key to achieving loosely coupled and\nmaintainable systems alongside concepts such\nas Polymorphism or Dependency injection."}),"\n",(0,s.jsx)(n.hr,{})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>r});var s=i(6540);const t={},a=s.createContext(t);function c(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);